== Introdução

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* objetivo 1
* objetivo 2
* objetivo N
____________________

Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

=== Linguagens

O que é uma linguagem? Deixamos para os linguistas e filósofos a definição
geral do que vem a ser uma linguagem, nos seus vários sentidos. Aqui nos
preocupamos apenas com as linguagens de programação, e daqui em diante quando se
falar em _linguagem_ será entendido que é uma linguagem de programação; 
quando for preciso tratar de outro tipo de linguagem, isso estará explícito no
texto.

Um _programa_ é uma seqüência de instruções que devem ser executadas por
um computador. Em outras palavras, um programa especifica um algoritmo de 
maneira executável. Uma _linguagem de programação_ é uma notação 
para escrever programas. Enquanto as linguagens naturais, como português,
são notações para comunicação entre pessoas, as linguagens de programação
existem, a princípio, para que o programador comunique ao computador as tarefas 
que devem ser realizadas. A linguagem deve ser, portanto, precisa; o computador 
não pode fazer julgamentos e resolver ambiguidades. Note que as linguagens de
programação, embora sejam formalizadas e definidas de maneira precisa, não são
a mesma coisa das linguagens formais estudadas num curso de autômatos. 

É importante notar também que um programa é 
freqüentemente um instrumento de comunicação entre programadores: é comum
que um deles tenha que ler e entender programas escritos por outro. Alguns
importantes cientistas da computação, aliás, defendem que a comunicação
entre programadores é o objetivo primário de um programa, a sua execução
sendo praticamente um ``efeito colateral''. Donald Knuth sugeriu que programação
é a arte de dizer a outra pessoa o que se quer que o computador faça. 

É impossível estudar compiladores sem estudar as linguagens de programação. Já
o contrário é possível: podemos estudar linguagens sem conhecer nada sobre 
compiladores. Desta forma, as linguagens se tornam simplesmente notações para
descrever algoritmos -- o que pode ser suficiente para algumas pessoas -- mas em
geral se quer executar esses algoritmos e não apenas descreve-los. Para isso
é necessário ter ao menos um conhecimento mínimo sobre compiladores. Entender
mais do que esse mínimo dá ao programador um maior poder e controle sobre
questões de eficiência dos seus programas. Também é importante para aprender
a usar melhor as linguagens de programação. 

=== O que é um Compilador?

Como visto, um compilador é um programa que traduz programas escritos em 
uma linguagem, chamada de _linguagem-fonte_, para outra linguagem,
a _linguagem-destino_. Normalmente, a linguagem-fonte é uma de alto 
nível, e a linguagem de destino é uma linguagem de máquina de algum processador, 
ou algum outro tipo de linguagem de baixo nível que seja executada diretamente 
por uma plataforma existente. O diagrama na Figura <<estrutura>> resume essa 
estrutura básica. 

[[estrutura]]
.Estrutura básica de um compilador.
image::images/introducao/compblock.eps[scaledwidth="60%"]

=== Processadores de Programas: Compiladores, Interpretadores e Máquinas Virtuais

Portanto, um compilador é um tradutor cujo objetivo principal é transformar
um programa para uma forma diretamente executável. Esta não é a única maneira
de executar programas em linguagens de alto-nível: uma alternativa é traduzir
e executar ao mesmo tempo. É o que fazem os _interpretadores_. Um 
interpretador puro tem que analisar e traduzir o programa-fonte toda vez
que ele precisa ser executado. 

Nos sistemas reais, modelos híbridos de interpretação e compilação são comuns.
Por exemplo, o compilador Java +javac+ não traduz os programas em linguagem 
Java para alguma linguagem de máquina de um processador, mas sim para a linguagem 
da máquina virtual Java (JVM), constituída de _bytecodes_. Uma implementação 
simples da JVM roda o programa compilado em _bytecodes_ interpretando-o. 
Atualmente, a maioria das máquinas virtuais Java compilam o programa em 
_bytecode_ para código nativo da máquina onde reside antes de executa-lo,
para melhorar o desempenho. Isso é chamado de compilação _Just In Time_,
ou JIT. Da mesma forma, os interpretadores reais não analisam e traduzem o
programa inteiro em cada execução; os programas são normalmente transformados
para alguma forma intermediária e parcialmente analisados para facilitar sua
execução. Também é comum que mesmo linguagens compiladas para código nativo
tenham um sistema de tempo de execução (_runtime_) que é acoplado aos
programas traduzidos para código de máquina e que, como o nome esclarece,
serve para dar suporte ao programa durante sua execução; desta forma, pode-se
ter um pouco de interpretação envolvida. Com vista nestes fatos, é difícil 
dividir exatamente os compiladores dos interpretadores. Nesta disciplina
consideramos principalmente os compiladores, mas muito do que é estudado serve
também para interpretadores. 

Aqui vale a pena considerar a relação entre o modelo semântico de uma linguagem
de programação e uma máquina virtual. De fato, cada linguagem de programação
pode ser vista como definindo uma máquina virtual que a executa. O modelo
semântico da linguagem é o funcionamento desta máquina. Um interpretador puro
para uma linguagem é uma máquina virtual para ela. Como no estudo da Organização
de Computadores, é necessário organizar as máquinas em camadas. Por isso existe,
em um nível mais baixo, a linguagem de máquina, que define o modelo de execução
do _hardware_ em si; logo acima temos o Sistema Operacional, que define uma 
linguagem com novas primitivas, conhecidas como _chamadas de sistema_.
Acima do SO podemos ter um compilador de linguagem de alto nível que traduz 
diretamente para código nativo, como o compilador C +gcc+; ou podemos ter 
uma máquina virtual que executa diretamente uma linguagem em _bytecode_, 
como é o caso da máquina virtual Java. Acima da JVM temos o compilador 
+javac+, que traduz um programa em Java para sua versão em _bytecode_. 

A definição do que é feito em _software_ e o que é feito em _hardware_ 
não é absoluta, sendo estabelecida por motivos de praticidade, desempenho e 
economia. Poderia se criar um processador que executasse diretamente a linguagem 
C, mas seu projeto seria complicadíssimo e seu custo muito alto. 

=== Aplicações da Tecnologia de Compiladores

Compiladores, ferramentas, análise de entrada. 

Portanto, um compilador é um tradutor cujo objetivo principal é transformar
um programa para uma forma diretamente executável. Esta não é a única maneira
de executar programas em linguagens de alto-nível: uma alternativa é traduzir
e executar ao mesmo tempo. É o que fazem os _interpretadores_. Um 
interpretador puro tem que analisar e traduzir o programa-fonte toda vez
que ele precisa ser executado. 

Nos sistemas reais, modelos híbridos de interpretação e compilação são comuns.
Por exemplo, o compilador Java \verb|javac| não traduz os programas em linguagem 
Java para alguma linguagem de máquina de um processador, mas sim para a linguagem 
da máquina virtual Java (JVM), constituída de _bytecodes_. Uma implementação 
simples da JVM roda o programa compilado em _bytecodes_ interpretando-o. 
Atualmente, a maioria das máquinas virtuais Java compilam o programa em 
_bytecode_ para código nativo da máquina onde reside antes de executa-lo,
para melhorar o desempenho. Isso é chamado de compilação _Just In Time_,
ou JIT. Da mesma forma, os interpretadores reais não analisam e traduzem o
programa inteiro em cada execução; os programas são normalmente transformados
para alguma forma intermediária e parcialmente analisados para facilitar sua
execução. Também é comum que mesmo linguagens compiladas para código nativo
tenham um sistema de tempo de execução (_runtime_) que é acoplado aos
programas traduzidos para código de máquina e que
serve para dar suporte ao programa durante sua execução; desta forma, pode-se
ter um pouco de interpretação envolvida. Com vista nestes fatos, é difícil 
dividir exatamente os compiladores dos interpretadores. Nesta disciplina
consideramos principalmente os compiladores, mas muito do que é estudado serve
também para interpretadores. 

Aqui vale a pena considerar a relação entre o modelo semântico de uma linguagem
de programação e uma máquina virtual. De fato, cada linguagem de \programacao{}
pode ser vista como definindo uma máquina virtual que a executa. O modelo
semântico da linguagem é o funcionamento desta máquina. Um interpretador puro
para uma linguagem é uma máquina virtual para ela. Como no estudo da Organização
de Computadores, é necessário organizar as máquinas em camadas. Por isso existe,
em um nível mais baixo, a linguagem de máquina, que define o modelo de execução
do _hardware_ em si; logo acima temos o Sistema Operacional, que define uma 
linguagem com novas primitivas, conhecidas como _chamadas de sistema_.
Acima do SO podemos ter um compilador de linguagem de alto nível que traduz 
diretamente para código nativo, como o compilador C \verb|gcc|; ou podemos ter 
uma máquina virtual que executa diretamente uma linguagem em _bytecode_, 
como é o caso da máquina virtual Java. Acima da JVM temos o compilador 
+javac+, que traduz um programa em Java para sua versão em _bytecode_. 

A definição do que é feito em _software_ e o que é feito em _hardware_ 
não é absoluta, sendo estabelecida por motivos de praticidade, desempenho e 
economia. Poderia se criar um processador que executasse diretamente a linguagem 
C, mas seu projeto seria complicadíssimo e seu custo muito alto. 

=== Organização de um Compilador

Vanguarda e retaguarda, análise e síntese, etapas. 

=== Exemplos

GCC, etc. 

